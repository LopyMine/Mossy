plugins {
	id("net.lopymine.mossy-plugin")
}

def modId = prop("mod_id")
def modName = prop("mod_name")
def modVersion = prop("mod_version")
def modGroup = prop("mod_group")
def modMavenGroup = prop("mod_maven_group")
def modDescription = prop("mod_description")
def modAuthors = prop("mod_authors")
def modLicense = prop("mod_license")
def lombokVersion = prop("lombok_version")

def mcVersion = stonecutter.current.version.toString() // Current MC version from "./versions/" folder
def currentMultiVersion = getCurrentMultiVersion(mcVersion)
println "[${mcVersion}] Supported Minecraft Versions: ${currentMultiVersion.toVersionRange()}"

def javaVersionAsInt = getJavaVersionAsInteger(mcVersion)
def javaVersion = JavaVersion.toVersion(javaVersionAsInt)
println "[${mcVersion}] Using Java: ${javaVersion.toString()}"

version = "${modVersion}+${currentMultiVersion.projectVersion}"
group = modMavenGroup

base {
	archivesName = modName
}

repositories {
	maven { url "https://maven.quiltmc.org/repository/release/" } // Stil for YACL
	maven { url "https://oss.sonatype.org/content/repositories/snapshots/" } // Stil for YACL
	maven {
		name "Terraformers" // ModMenu
		url "https://maven.terraformersmc.com/"
	}
	maven {
		name 'Xander Maven' // YACL
		url 'https://maven.isxander.dev/releases'
	}
	maven {
		url "https://maven.nucleoid.xyz/"
		name "Nucleoid"
	}
	// For Mod Menu, because at 1.20.4 it needs PlaceHolder API, see https://github.com/TerraformersMC/ModMenu/issues/752
}

//mossyDependencies {
//	minecraft = "1.21"
////	mappings = "blabla"
////	lombok = "1.28.33"
////	fabric_api = "1.21"
////	mod_menu = "12312.55"
//}

dependencies {
	minecraft "com.mojang:minecraft:${mcVersion}"
	mappings "net.fabricmc:yarn:${prop("build.yarn")}:v2"
	modImplementation "net.fabricmc:yarn:${prop("build.yarn")}:v2"

//	// Lombok
//	compileOnly "org.projectlombok:lombok:${lombokVersion}"
//	annotationProcessor "org.projectlombok:lombok:${lombokVersion}"

	// Fabric API
	modImplementation "net.fabricmc.fabric-api:fabric-api:${prop("build.fabric_api")}"

	// Mod Menu
	modImplementation "com.terraformersmc:modmenu:${prop("dep.modmenu")}"

	// YACL
	def minecraftVersionsWithOldYACLMaven = Set.of("1.19.4", "1.20", "1.20.2", "1.20.3")
	def yaclVersion = prop("dep.yacl")
	if (minecraftVersionsWithOldYACLMaven.contains(mcVersion)) {
		modImplementation "dev.isxander.yacl:yet-another-config-lib-fabric:${substringBefore(yaclVersion.toString(), "-")}"
	} else {
		modImplementation "dev.isxander:yet-another-config-lib:${yaclVersion}"
	}
}

processResources {
	def props = [:]
	props.put("mod_id", modId.toString())
	props.put("mod_authors", modAuthors.toString())
	props.put("mod_group", modGroup)
	props.put("mod_description", modDescription.toString())
	props.put("mod_name", modName.toString())
	props.put("mod_license", modLicense.toString())
	props.put("version", version.toString())
	props.put("fabric_loader", prop("build.fabric_loader").toString())
	props.put("minecraft", mcVersion.toString())
	props.put("java", javaVersionAsInt.toString())
	props.put("fabric_api_id", stonecutter.compare("1.19.1", mcVersion) >= 0 ? "fabric" : "fabric-api")

	props.each { key, value ->
		inputs.property key, value
	}

	filesMatching(["*.json", "*.json5", "assets/${modId}/lang/*.json".toString()]) {
		expand(props)
	}

	filesMatching("aws/*.accesswidener") {
		if (!it.getName().startsWith(mcVersion)) {
			it.exclude()
		}
	}

	filesMatching("mixins/*.mixins.json") {
		def name = substringBefore(it.getName(), "-")
		if (name != mcVersion) {
			it.exclude()
		} else {
			expand(props)
		}
	}
}

stonecutter {
	swap("mod_version", "\"${prop("mod_version")}\";")
	swap("mod_id", "\"${prop("mod_id")}\";")
	swap("mod_name", "\"${prop("mod_name")}\";")
}

tasks.withType(JavaCompile).configureEach {
	it.options.release = (javaVersionAsInt as int)
}

java {
	// Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
	// if it is present.
	// If you remove this line, sources will not be generated.
	withSourcesJar()

	sourceCompatibility = javaVersion
	targetCompatibility = javaVersion
}

jar {
	from("LICENSE") {
		rename { "${it}_${project.base.archivesName.get()}" }
	}
}

publishMods {
	curseforge {
		if (currentMultiVersion.minVersion != currentMultiVersion.maxVersion) {
			minecraftVersionRange {
				start = currentMultiVersion.minVersion
				end = currentMultiVersion.maxVersion
			}
		} else {
			minecraftVersions.add(currentMultiVersion.maxVersion)
		}
	}

	modrinth {
		if (currentMultiVersion.minVersion != currentMultiVersion.maxVersion) {
			minecraftVersionRange {
				start = currentMultiVersion.minVersion
				end = currentMultiVersion.maxVersion
			}
		} else {
			minecraftVersions.add(currentMultiVersion.maxVersion)
		}
	}
}

// Cannot be static!
int getJavaVersionAsInteger(String minecraftVersion) {
	return stonecutter.compare("1.20.5", minecraftVersion) == 1 ?
			stonecutter.compare("1.18", minecraftVersion) == 1 ?
					stonecutter.compare("1.16.5", minecraftVersion) == 1 ?
							8
							:
							16
					:
					17
			:
			21
}

MultiVersion getCurrentMultiVersion(String minecraftVersion) {
	def versions = prop("publication_versions").toString().split(" ")
	for (version in versions) {
		def split = version.substring(0, version.length()-1).split("\\[")
		def project = split[0]
		if (project == minecraftVersion) {
			def supportedVersionsString = split[1]
			if (supportedVersionsString.contains("-")) {
				def supportedVersions = supportedVersionsString.split("-")
				return new MultiVersion(projectVersion: minecraftVersion, minVersion: supportedVersions[0], maxVersion: supportedVersions[1])
			} else if (supportedVersionsString.contains(".")) {
				return new MultiVersion(projectVersion: minecraftVersion, minVersion: minecraftVersion, maxVersion: supportedVersionsString)
			} else {
				def a = project.indexOf(".")
				def i = project.lastIndexOf(".")
				if (a == i) {
					i = project.length()
				}
				def p = project.substring(0, i)
				def supportedMaxVersion = "${p}.${supportedVersionsString}"
				return new MultiVersion(projectVersion: minecraftVersion, minVersion: minecraftVersion, maxVersion: supportedMaxVersion)
			}
		}
	}
	return new MultiVersion(projectVersion: minecraftVersion, minVersion: minecraftVersion, maxVersion: minecraftVersion)
}

class MultiVersion {
	String projectVersion
	String minVersion
	String maxVersion

	String toString() {
		if (minVersion != maxVersion) {
			return "${projectVersion}[${minVersion}-${maxVersion}]"
		}
		return "${projectVersion}[${maxVersion}]"
	}

	String toVersionRange() {
		if (minVersion == maxVersion) {
			return maxVersion
		}
		def aMin = minVersion.indexOf(".")
		def bMin = minVersion.lastIndexOf(".")
		if (aMin == bMin) {
			bMin = minVersion.length()
		}
		def minMain = minVersion.substring(0, bMin)

		def aMax = maxVersion.indexOf(".")
		def bMax = maxVersion.lastIndexOf(".")
		if (aMax == bMax) {
			bMax = maxVersion.length()
		}
		def maxMain = maxVersion.substring(0, bMax)
		def maxMinor = maxVersion.substring(bMax+1, maxVersion.length())
		if (minMain == maxMain) {
			return "${minVersion}-${maxMinor}"
		}
		return "${minVersion}-${maxVersion}"
	}
}

String prop(String key) {
	return findProperty(key).toString()
}